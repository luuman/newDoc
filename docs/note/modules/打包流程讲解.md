# 打包流程讲解

##

E2EE SDK
HEM SDK
直播 SDK
基础配置
patches 部分
Electron 加固
指纹 SDK
自研会议 SDK
主进程
渲染进程 主窗口 截图 图片查看 文件查看 其他窗口
打包配置

patches
misi

exeConfig.js
config.js
msiConfig.js

## SDK

### 初始化 renderer start

bridge.js

## 指纹 SDK

SDKrisk

init1v1SDK E2ESDK

nsis_build\installer.nsi

```
!define PRODUCT_DIR_REGKEY "Software\Microsoft\Windows\CurrentVersion\App Paths\${PRODUCT_NAME}.exe"
!define PRODUCT_UNINST_KEY "Software\Microsoft\Windows\CurrentVersion\Uninstall\${PRODUCT_NAME}"
!define PRODUCT_UNINST_ROOT_KEY "HKCU"
!define CHILD_PROCESS_NAME_2 "CrystalSDK.exe"
!define CHILD_PROCESS_NAME_3 "cmeetingsegment.exe"

!include "MUI2.nsh"
!include WinMessages.nsh
!include "System.nsh"

!macro customWelcomePage
    ; WELCOME Page
	!insertMacro MUI_PAGE_WELCOME
!macroEnd

!macro customHeader
    ShowInstDetails show
    ShowUnInstDetails show
    SpaceTexts show
!macroend

!macro preInit
    SetRegView 64
    WriteRegExpandStr HKLM "${INSTALL_REGISTRY_KEY}" InstallLocation "$LOCALAPPDATA\${PRODUCT_NAME}"
    WriteRegExpandStr HKCU "${INSTALL_REGISTRY_KEY}" InstallLocation "$LOCALAPPDATA\${PRODUCT_NAME}"
    SetRegView 32
    WriteRegExpandStr HKLM "${INSTALL_REGISTRY_KEY}" InstallLocation "$LOCALAPPDATA\${PRODUCT_NAME}"
    WriteRegExpandStr HKCU "${INSTALL_REGISTRY_KEY}" InstallLocation "$LOCALAPPDATA\${PRODUCT_NAME}"
!macroend

!macro customInit

!macroend

!macro customInstall
    Delete "$SMPROGRAMS\${PRODUCT_NAME}\Uninstall ${PRODUCT_NAME}.lnk"
    Delete "$SMPROGRAMS\${PRODUCT_NAME}\Website.lnk"
    Delete "$SMPROGRAMS\${PRODUCT_NAME}\${PRODUCT_NAME}.lnk"

    DeleteRegKey ${PRODUCT_UNINST_ROOT_KEY} "${PRODUCT_UNINST_KEY}"
    DeleteRegKey ${PRODUCT_UNINST_ROOT_KEY} "${PRODUCT_DIR_REGKEY}"

    Delete "C:\Users\Public\Desktop\${PRODUCT_NAME}.lnk"
    Delete "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\${PRODUCT_NAME}.lnk"

    创建快捷方式
    ; CreateShortCut
    CreateShortCut "$DESKTOP\${PRODUCT_NAME}.lnk" "$INSTDIR\${PRODUCT_NAME}.exe"
    ExecShell "startunpin" "$STARTMENU\${PRODUCT_NAME}.lnk"
    ExecShell "startunpin" "$SMPROGRAMS\${PRODUCT_NAME}.lnk"
    IfFileExists "$QUICKLAUNCH\User Pinned\TaskBar\${PRODUCT_NAME}.lnk" file_found file_not_found
    file_found:
        ${StdUtils.InvokeShellVerb} $0 "$INSTDIR" "${PRODUCT_NAME}.exe" ${StdUtils.Const.ShellVerb.PinToTaskbar}
        CreateShortCut "$QUICKLAUNCH\User Pinned\TaskBar\${PRODUCT_NAME}.lnk" "$INSTDIR\${PRODUCT_NAME}.exe"
        goto end_of_found
    file_not_found:
        ExecShell "taskbarunpin" "$QUICKLAUNCH\User Pinned\TaskBar\${PRODUCT_NAME}.lnk"
    end_of_found:

    IfFileExists "$QUICKLAUNCH\User Pinned\TaskBar\${PRODUCT_NAME} (2).lnk" file_found2 file_not_found2
    file_found2:
        CreateShortCut "$QUICKLAUNCH\User Pinned\TaskBar\${PRODUCT_NAME} (2).lnk" "$INSTDIR\${PRODUCT_NAME}.exe"
        goto end_of_found2
    file_not_found2:
        ExecShell "taskbarunpin" "$QUICKLAUNCH\User Pinned\TaskBar\${PRODUCT_NAME} (2).lnk"
    end_of_found2:

    ; $0: SysTray Window Handle
    FindWindow $0 "Shell_TrayWnd" ""
    FindWindow $0 "TrayNotifyWnd" "" $0
    FindWindow $0 "SysPager" "" $0
    FindWindow $0 "ToolbarWindow32" "" $0

    ; Create RECT struct
    System::Call "*${stRECT} .r1"
    ; Get windows information
    System::Call "User32::GetWindowRect(i, i) i (i r0, r1) .r2"
    ; Get left/top/right/bottom coords
    ; $2: Left, $3: Top, $4: Right, $5: Bottom
    System::Call "*$1${stRECT} (.r2, .r3, .r4, .r5)"
    System::Free $1

    ; $2: Width
    IntOp $2 $4 - $2
    ; $3: Height
    IntOp $3 $5 - $3

    ; $4: Small Icon Width
    System::Call 'User32::GetSystemMetrics(i 49) i .r4'
    ; $5: Small Icon Height
    System::Call 'User32::GetSystemMetrics(i 50) i .r5'

    ; $7: y - Start at the bottom
    IntOp $7 $4 / 2
    IntOp $7 $3 - $7
    LoopY:
      ; $6: X - Start at the right
      IntOp $6 $5 / 2
      IntOp $6 $2 - $6
      LoopX:
        SendMessage $0 ${WM_MOUSEMOVE} 0 "$6 | $7"
        IntOp $6 $6 - $4
        IntCmp $6 0 EndLoopX EndLoopX LoopX
      EndLoopX:
      IntOp $7 $7 - $5
      IntCmp $7 0 EndLoopY EndLoopY LoopY
    EndLoopY:
!macroend

!macro customInstallMode
    StrCpy $isForceCurrentInstall "1"
    StrCpy $isForceMachineInstall "0"
!macroend

回调函数（）
!macro customRemoveFiles
    删除数据目录
    RMDir /r "$INSTDIR"
    删除安装目录
    RMDir /r "$INSTDIR-updater"
    删除文件
    delete "$INSTDIR\..\..\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\${PRODUCT_NAME}.lnk"
    delete "$INSTDIR\..\..\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\${PRODUCT_NAME} (2).lnk"
    delete "$INSTDIR\..\..\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\Tombstones\${PRODUCT_NAME}*.lnk"
!macroend
```

```js
const { debug } = require("./config");
const { name } = require("./package.json");
const appId = `io.${name}.www`;
const signConf = debug
  ? {}
  : {
      signingHashAlgorithms: ["sha1", "sha256"],
      // certificateFile:'./matrx.pfx',
      certificateSubjectName: "CN=Transmex Systems International Pte. Ltd.",
      rfc3161TimeStampServer: "http://timestamp.digicert.com"
    };
module.exports = {
  electronDist: "avr_electron_6.1.12",
  afterSign: "./avr_scripts/after-sign.js",
  // afterAllArtifactBuild: "./nsis_build/copy.js",
  asarUnpack: ["**\\*.node", "out", "sdk", "sdk/lib", "public"],
  appId: appId,
  productName: name,
  artifactName: name.toLowerCase() + "-${os}-${version}.${ext}",
  copyright: "Copyright © 2021-2022 TSI Tech Pte. Ltd. All rights reserved.",
  mac: {
    category: "Matrx"
  },
  directories: {
    // output: "./dist_electron/${platform}/${arch}/"
  },
  extraResources: [
    // {
    //   "from": "resources/dll",
    //   "to": "../"
    // }
  ],
  win: {
    target: [
      // "zip",
      {
        target: "nsis",
        arch: ["ia32"]
      }
    ],
    ...signConf,
    verifyUpdateCodeSignature: false
  },
  nsis: {
    perMachine: false,
    oneClick: false,
    allowToChangeInstallationDirectory: false,
    // set default install path
    // include:'nsis_build/installer.nsh',
    include: "nsis_build/installer.nsi",
    allowElevation: true,
    // 语言选择
    displayLanguageSelector: true,
    installerIcon: "build/icons/icon.ico",
    // 删除用户数据在卸载时
    deleteAppDataOnUninstall: true,
    // license:"LICENSE",
    // 支持语言配置
    installerLanguages: ["en_US"]
  },
  //   升级 （自动更新URL）
  publish: [
    {
      provider: "generic",
      //   版本信息
      channel: "alpha",
      //   服务端版本信息文件
      url: ""
    }
  ]
};
```

nsi 配置 electronBudler Cache nsi nsis-3-3-3

## 自动更新

initUpdater 初始化更新信息

```js
import { skipUpdateExpireTime } from "../../config";
import { getStore, setStore } from "./store";
import { autoUpdater } from "electron-updater";

const { ipcMain, shell } = require("electron");
const fs = require("fs");
const path = require("path");
const { checkHash } = require("./mainUtils");
import * as log from "@/logs/devBackLog";

let updateObj = null;
let updateTimer = null;
let endTime = null;
let initTime = 0;
let refreshTimer = null;
let refreshInterval = skipUpdateExpireTime;

if (process.env.NODE_ENV === "development") {
  autoUpdater.updateConfigPath = path.join(
    __filename,
    "../../dist_electron/win-unpacked/resources/app-update.yml"
  );
}

export default class AppUpdater {
  constructor(data) {
    this.initData(data);
    this.initEvent();
  }

  initData(data) {
    const {
      updateServer,
      updateMarketUrl,
      updateWebUrl,
      targetVersion,
      updatePath,
      reminderInterval,
      description,
      forceUpdate,
      canSkipUpdate,
      updateNow,
      manualCheck
    } = data;

    this.updatePath = updatePath || "";
    this.updateUrl = `${updateServer}${this.updatePath}`;
    this.updateNow = updateNow;
    this.forceUpdate = forceUpdate;
    this.canSkipUpdate = canSkipUpdate || false;
    this.fileSize = 0;
    this.description = description;
    this.downloadSize = 0;
    this.downloadPercent = 0;
    this.downloadedPath = "";
    this.cancellationToken = null;
    this.reminderInterval = reminderInterval || skipUpdateExpireTime;
    this.updateWebUrl = updateWebUrl;
    this.updateMarketUrl = updateMarketUrl;
    this.targetVersion = targetVersion;
    this.fileSha512 = null;
    this.skipVer = false;
    this.clickLater = false;
    this.startUpdate = false;
    this.manualCheck = manualCheck || false;

    log.info("updateUrl", this.updateUrl);
    log.info("updateWebUrl", this.updateWebUrl);

    this.setUpdaterUrl();

    if (this.updateNow) {
      this.checkUpdater();
    } else {
      if (this.manualCheck) {
        ipcMain.emit("SEND-CURRENT-WIN-MSG", {
          type: "SHOW_CHECK_UPDATE_TIP",
          data: {}
        });
      }
    }
  }

  setUpdaterUrl() {
    try {
      if (!this.updateUrl) return;
      // autoUpdater.setFeedURL(updateUrl);
      autoUpdater.setFeedURL({
        provider: "generic",
        channel: "alpha",
        url: this.updateUrl
      });
    } catch (err) {
      log.error("autoUpdater setUpdaterUrl=>", err);
    }
  }

  async initEvent() {
    autoUpdater.logger = log;
    // 是否自动下载
    autoUpdater.autoDownload = false;
    // 是否支持降级
    autoUpdater.allowDowngrade = false;
    // 是否支持自动更新
    autoUpdater.autoInstallOnAppQuit = false;

    autoUpdater.on("error", (err) => {
      log.error("autoUpdater=>error", err);
      ipcMain.emit("SEND-CURRENT-WIN-MSG", {
        type: "CHECK_UPDATE_ERROR",
        data: {}
      });
    });

    this.mainEvent();

    autoUpdater.on("checking-for-update", () => {
      log.debug("autoUpdater=>CheckingForUpdate");
    });
    autoUpdater.on("update-available", (info) => {
      log.debug("autoUpdater=>update-available", info);

      // 判断是否忽略更新
      // if(isExpire)
      {
        // info.version !== skipUpdateVersion &&
        // 更新过 清楚记录的忽略版本
        setStore("storage.skipUpdateVersion", "");
        setStore("storage.skipUpdateTime", "");
        this.fileSize = info.files[0] ? info.files[0].size : 0;
        this.fileSha512 = info.sha512;
        this.startUpdate = false;
        ipcMain.emit("SEND-CURRENT-WIN-MSG", {
          type: "CHECK_UPDATE_NEW_VERSION",
          data: { manualCheck: this.manualCheck }
        });
        ipcMain.emit("SEND-CURRENT-WIN-MSG", {
          type: "SET_UPDATE_MODAL",
          data: {
            updateVisible: true,
            processVisible: false,
            downloadedVisible: false,
            newVersion: info.version,
            newVersionInfo: this.description,
            forceUpdate: this.forceUpdate,
            fileSize: this.fileSize,
            canSkipUpdate: this.canSkipUpdate,
            updateWebUrl: this.updateWebUrl,
            updateMarketUrl: this.updateMarketUrl
          }
        });
      }
    });

    autoUpdater.on("update-not-available", (info) => {
      log.debug("autoUpdater=>UpdateNotAvailable", info);
      ipcMain.emit("SEND-CURRENT-WIN-MSG", {
        type: "SHOW_CHECK_UPDATE_TIP",
        data: {}
      });
    });

    autoUpdater.on("download-progress", (params) => {
      log.debug("autoUpdater=>DownloadProgress", params);
      if (!this.cancellationToken || !this.startUpdate) return;
      this.downloadSize = params.transferred;
      const percent = parseFloat(params.percent.toFixed(2));
      if (this.downloadPercent <= percent) {
        this.downloadPercent = percent;
        ipcMain.emit("SEND-CURRENT-WIN-MSG", {
          type: "SET_UPDATE_MODAL",
          data: {
            updateVisible: false,
            processVisible: true,
            downloadProcess: this.downloadPercent,
            downloadSize: this.downloadSize
          }
        });
      }
    });

    autoUpdater.on("update-downloaded", (e) => {
      log.debug("autoUpdater=>downloaded", e);
      this.downloadPercent = 0;
      if (!this.cancellationToken || !this.startUpdate) return;
      this.downloadSize = e.files[0] ? e.files[0].size : 0;
      ipcMain.emit("SEND-CURRENT-WIN-MSG", {
        type: "SET_UPDATE_MODAL",
        data: {
          downloadProcess: 100,
          downloadSize: this.downloadSize
        }
      });
      // 提醒用户更新
      const timer = setTimeout(() => {
        ipcMain.emit("SEND-CURRENT-WIN-MSG", {
          type: "SET_UPDATE_MODAL",
          data: {
            updateVisible: false,
            downloadedVisible: true,
            downloadProcess: 100
          }
        });
        ipcMain.emit("SEND-CURRENT-WIN-MSG", {
          type: "SET_UPDATE_MODAL",
          data: {
            processVisible: false
          }
        });
        clearTimeout(timer);
      }, 1000);
    });
  }

  async checkUpdater() {
    try {
      if (!this.manualCheck) {
        const isSkip = await this.checkSkip();

        log.debug("isSkip", isSkip);
        if (isSkip) return;
      }

      if (this.updateMarketUrl) {
        ipcMain.emit("SEND-CURRENT-WIN-MSG", {
          type: "CHECK_UPDATE_NEW_VERSION",
          data: { manualCheck: this.manualCheck }
        });
        ipcMain.emit("SEND-CURRENT-WIN-MSG", {
          type: "SET_UPDATE_MODAL",
          data: {
            updateVisible: true,
            newVersion: this.targetVersion,
            newVersionInfo: this.description,
            forceUpdate: this.forceUpdate,
            canSkipUpdate: this.canSkipUpdate,
            updateMarketUrl: this.updateMarketUrl,
            updateWebUrl: this.updateWebUrl
          }
        });
        return;
      }
      // 应用市场发布版本不检测更新
      if (process.env.npm_lifecycle_event === "electron:release") {
        ipcMain.emit("SEND-CURRENT-WIN-MSG", {
          type: "SHOW_CHECK_UPDATE_TIP",
          data: {}
        });
        return;
      }

      if (this.updateWebUrl) {
        ipcMain.emit("SEND-CURRENT-WIN-MSG", {
          type: "CHECK_UPDATE_NEW_VERSION",
          data: { manualCheck: this.manualCheck }
        });
        ipcMain.emit("SEND-CURRENT-WIN-MSG", {
          type: "SET_UPDATE_MODAL",
          data: {
            updateVisible: true,
            newVersion: this.targetVersion,
            newVersionInfo: this.description,
            forceUpdate: this.forceUpdate,
            canSkipUpdate: this.canSkipUpdate,
            updateWebUrl: this.updateWebUrl,
            updateMarketUrl: this.updateMarketUrl
          }
        });
        return;
      }

      this.checkForUpdates();
    } catch (err) {
      log.error("autoUpdater checkUpdater=>", err);
    }
  }

  checkForUpdates() {
    // 检测更新
    autoUpdater
      .checkForUpdates()
      .then((checkResult) => {
        // console.log('autoUpdater=>checkForUpdates：', checkResult);
        this.cancellationToken = checkResult.cancellationToken;

        return checkResult;
      })
      .catch((err) => {
        log.error("autoUpdater checkForUpdates=>", err);
      });
  }

  checkSkip() {
    try {
      const { skipUpdateVersion, skipUpdateTime } = getStore("storage");
      log.debug(
        "skipUpdateVersion",
        skipUpdateVersion,
        "skipUpdateTime",
        skipUpdateTime
      );

      let isExpire = false;
      try {
        if (skipUpdateTime) {
          endTime = Number(skipUpdateTime) + this.reminderInterval;

          log.debug("skipTime:", endTime, Date.now() / 1000);

          isExpire = endTime <= Date.now() / 1000;
        }
      } catch (e) {
        log.debug("update Expire err", e);
        isExpire = false;
      }

      log.debug("isExpire:", isExpire, this.targetVersion, skipUpdateVersion);

      if (
        this.targetVersion === skipUpdateVersion ||
        (!isExpire && skipUpdateTime)
      ) {
        if (this.skipVer) {
          startUpdateTimer(skipUpdateTime);
        }
        return true;
      } else {
        clearInterval(updateTimer);

        return false;
      }
    } catch (e) {
      log.error("checkSkip err", e);
    }
  }

  downloadUpdater() {
    // 开始下载
    try {
      autoUpdater
        .downloadUpdate(this.cancellationToken)
        .then((downloadPath) => {
          log.debug("autoUpdater downloadUpdate=>", downloadPath);
          this.downloadedPath = downloadPath[0];

          return downloadPath;
        })
        .catch((err) => {
          log.error("autoUpdater downloadUpdate=>", err);
        });
    } catch (err) {
      log.error("autoUpdater downloadUpdater func=>", err);
    }
  }

  updateFail() {
    log.error("downloadedPath err=>", this.downloadedPath);
    ipcMain.emit("SEND-CURRENT-WIN-MSG", {
      type: "SET_UPDATE_FAIL",
      data: {
        updateVisible: false,
        processVisible: false,
        downloadedVisible: false
      }
    });
  }

  mainEvent() {
    // 取消下载
    ipcMain.on("sys:cancelUpdate", () => {
      this.cancellationToken = null;
      clearInterval(updateTimer);
      clearInterval(refreshTimer);
      startRefreshTimer();
    });

    ipcMain.on("sys:updateNow", () => {
      this.downloadUpdater();
      this.startUpdate = true;
      clearInterval(updateTimer);
      clearInterval(refreshTimer);
    });

    ipcMain.on("sys:updateLater", (e, t) => {
      log.debug("updateLater=>", t);
      this.clickLater = true;
      this.skipVer = false;
      this.startUpdate = false;
      startUpdateTimer(t);
    });

    ipcMain.on("sys:skipUpdater", () => {
      log.debug("skipUpdater=>");
      this.skipVer = true;
      this.clickLater = false;
      this.startUpdate = false;
      startRefreshTimer();
    });

    ipcMain.on("sys:nowRestart", async () => {
      log.debug("sys:nowRestart downloadedPath", this.downloadedPath);
      // log.debug('sys:nowRestart cancellationToken', this.cancellationToken)
      try {
        ipcMain.emit("MAIN-WIN-IS-CLOSE");
        if (fs.existsSync(this.downloadedPath)) {
          const check = await checkHash(this.downloadedPath, this.fileSha512);
          log.debug("check", check);
          if (check) {
            this.openInstall(this.downloadedPath);
            // autoUpdater.quitAndInstall(false, true);
          } else {
            this.updateFail();
          }
        } else {
          this.updateFail();
        }
      } catch (err) {
        log.error(
          "sys:nowRestart this.downloadedPath err",
          err.message,
          err.stack
        );
      }
    });
  }

  openInstall(url) {
    try {
      shell.openExternal(url).then(() => {
        log.log("shell openInstall then", url);
        // ipcMain.emit('UPDATE_AND_QUIT_APP');
      });
    } catch (e) {
      log.error("shell openInstall err", e);
      this.updateFail();
    }
  }
}

export function initUpdater() {
  setStore("storage.skipUpdateTime", "");

  ipcMain.on("start-checkUpdate", async (e, res) => {
    log.info("getVersionInfo res:", res);
    // updateType
    // 0:  not need update
    // 1:  mandatory update
    // 2:  normal update
    // 3:  suggested update
    if (res) {
      if (!res.downLoadUrl && !res.updateWebUrl && !res.updateMarketUrl) {
        if (res.manualCheck) {
          ipcMain.emit("SEND-CURRENT-WIN-MSG", {
            type: "SHOW_CHECK_UPDATE_TIP",
            data: {}
          });
        }
        return;
      }
      if (res.refreshInterval && typeof res.refreshInterval === "number") {
        refreshInterval = res.refreshInterval;
      }
      if (!res.manualCheck) {
        startRefreshTimer();
      }
      const forceUpdate = res.updateType === 1;
      const canSkipUpdate = res.updateType === 3;
      const updateNow =
        typeof res.updateType === "number" && res.updateType !== 0;

      const downloadUrl = getUploadPath(res.downLoadUrl);

      const updateData = {
        ...res,
        //  updatePath: downloadUrl.pathname,
        updateServer: downloadUrl,
        forceUpdate,
        canSkipUpdate,
        updateNow
      };

      if (!updateObj) {
        updateObj = new AppUpdater(updateData);
      } else {
        updateObj.initData(updateData);
      }
      // console.log('update0000', updateObj)
    }
  });
}

function getUploadPath(url) {
  if (!url) return "";
  var a = url.split("/");
  a.length = a.length - 1;
  return a.join("/");
}

// function tow(n) {
//     return n >= 0 && n < 10 ? '0' + n : '' + n;
// }

function getDate() {
  //时间到了执行事件；
  if (Date.now() - endTime * 1000 >= 0) {
    if (updateObj) {
      ipcMain.emit("SEND-CURRENT-WIN-MSG", {
        type: "start-CheckUpdateVersion",
        data: {}
      });
    }
    clearInterval(updateTimer);
  }
}

function startUpdateTimer(t) {
  // console.log('startUpdateTimer', t);
  if (!updateObj) return;

  if (t) {
    endTime = Number(t) + updateObj.reminderInterval;
  }
  // console.log('startUpdateTimer11', endTime);
  if (endTime) {
    clearInterval(updateTimer);
    clearInterval(refreshTimer);
    updateTimer = setInterval(getDate, 1000 * 10);
  }
}

function refresh() {
  if ((Date.now() - initTime) / 1000 >= refreshInterval) {
    if (updateObj) {
      ipcMain.emit("SEND-CURRENT-WIN-MSG", {
        type: "start-CheckUpdateVersion",
        data: {}
      });
    }
    log.log("refresh CheckUpdateVersion", initTime);
    clearInterval(refreshTimer);
    refreshTimer = null;
  }
}

function startRefreshTimer() {
  try {
    initTime = Date.now();
    log.log("startRefreshTimer", initTime);
    // console.log('initTime', initTime);

    if (initTime) {
      clearInterval(updateTimer);
      clearInterval(refreshTimer);
      refreshTimer = null;

      refreshTimer = setInterval(refresh, 1000 * 5);
    }
  } catch (e) {
    log.error("startRefreshTimer err=>", e);
  }
}
```

msi 支持静默安装 msiexec

appx 市场 app

openssl 自签证书 pfs https://www.jianshu.com/p/1a0958202087
